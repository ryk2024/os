q1
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void make_toks(char *s, char *tok[])
{
    int i = 0;
    char *p;

    p = strtok(s, " ");
    while (p != NULL)
    {
        tok[i++] = p;
        p = strtok(NULL, " ");
    }

    tok[i] = NULL;
}

void typeline(char *fn, char *op)
{
    int fh, i, j, n;
    char c;

    fh = open(fn, O_RDONLY);
    if (fh == -1)
    {
        printf("File %s not found.\n", fn);
        return;
    }

    if (strcmp(op, "a") == 0)
    {
        while (read(fh, &c, 1) > 0)
            printf("%c", c);
        close(fh);
        return;
    }

    n = atoi(op);
    if (n > 0)
    {
        i = 0;
        while (read(fh, &c, 1) > 0)
        {
            printf("%c", c);
            if (c == '\n')
                i++;
            if (i == n)
                break;
        }
    }

    if (n < 0)
    {
        i = 0;
        while (read(fh, &c, 1) > 0)
        {
            if (c == '\n')
                i++;
        }
        lseek(fh, 0, SEEK_SET);
        j = 0;
        while (read(fh, &c, 1) > 0)
        {
            if (c == '\n')
                j++;
            if (j == i + n)
                break;
        }
        while (read(fh, &c, 1) > 0)
        {
            printf("%c", c);
        }
    }

    close(fh);
}

int main()
{
    char buff[80], *args[10];
    int pid;

    while (1)
    {
        printf("myshell$");
        fflush(stdin);
        fgets(buff, 80, stdin);
        buff[strlen(buff) - 1] = '\0';
        make_toks(buff, args);
        if (strcmp(args[0], "typeline") == 0)
            typeline(args[2], args[1]);
        else
        {
            pid = fork();
            if (pid > 0)
                wait();
            else
            {
                if (execvp(args[0], args) == -1)
                    printf("Bad command.\n");
            }
        }
    }

    return 0;
}

q2

// #include <stdio.h>
// #include <stdlib.h>
// #include <stdbool.h>

// struct Process
// {
//     int name, at, bt, tat, wt, rt;
// };

// void main()
// {
//     int i, n, timeq;
//     printf("Enter number of processes : ");
//     scanf("%d", &n);
//     struct Process p[n];
//     for (i = 0; i < n; i++)
//     {
//         p[i].name = i + 1;
//     }

//     for (i = 0; i < n; i++)
//     {
//         printf("\n Enter Arrival time and Burst time for process P%d : ", i + 1);
//         scanf("%d%d", &p[i].at, &p[i].bt);
//         p[i].rt = p[i].bt;
//     }
//     printf("\n Enter Time Quantum : ");
//     scanf("%d", &timeq);
//     int time = 0, io_wait = 2, completed = 0;
//     printf("\n\n Gantt Chart :\n--------------------\n");
//     while (completed < n)
//     {
//         bool found = false;
//         for (i = 0; i < n; i++)
//         {
//             if (p[i].at <= time && p[i].rt > 0)
//             {
//                 found = true;
//                 if (p[i].rt > timeq)
//                 {
//                     printf("| P%d ", p[i].name);
//                     time += timeq;
//                     p[i].rt -= timeq;
//                 }
//                 else
//                 {
//                     printf("| P%d ", p[i].name);
//                     time += p[i].rt;
//                     p[i].rt = 0;
//                     p[i].tat = time - p[i].at;
//                     p[i].wt = p[i].tat - p[i].bt;
//                     completed++;
//                 }
//             }
//             else if (p[i].at > time)
//             {
//                 printf("-");
//                 time += io_wait;
//             }
//         }
//         if (!found)
//             time++;
//     }
//     printf("\n Process\tAT\tBT\tTAT\tWT\n");
//     printf("\n----------------------------------------\n");
//     float avgtat = 0, avgwt = 0;
//     for (i = 0; i < n; i++)
//     {
//         printf(" P%d    |\t%4d  |\t%4d  |\t%4d  |\t%4d |\n", p[i].name, p[i].at, p[i].bt, p[i].tat, p[i].wt);
//         avgwt = avgwt + p[i].wt;
//         avgtat = avgtat + p[i].tat;
//     }
//     printf("\n\n Average Turn Around Time : %f", avgtat / n);
//     printf("\n Average Waiting Time : %f\n", avgwt / n);
// }

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

// Define a structure to represent a process
struct Process
{
    int name, at, bt, tat, wt, rt; // Process attributes: name, arrival time, burst time, turnaround time, waiting time, remaining time
};

void main()
{
    int i, n, timeq; // Declare variables for iteration, number of processes, and time quantum
    printf("Enter number of processes : ");
    scanf("%d", &n);

    // Declare an array of structures to store information about each process
    struct Process p[n];
    
    // Initialize the names of the processes
    for (i = 0; i < n; i++)
    {
        p[i].name = i + 1;
    }

    // Input arrival time and burst time for each process
    for (i = 0; i < n; i++)
    {
        printf("\n Enter Arrival time and Burst time for process P%d : ", i + 1);
        scanf("%d%d", &p[i].at, &p[i].bt);
        p[i].rt = p[i].bt; // Set remaining time initially equal to burst time
    }

    // Input time quantum
    printf("\n Enter Time Quantum : ");
    scanf("%d", &timeq);

    int time = 0, io_wait = 2, completed = 0; // Initialize simulation variables
    printf("\n\n Gantt Chart :\n--------------------\n");

    // Simulation loop
    while (completed < n)
    {
        bool found = false;

        // Iterate through processes
        for (i = 0; i < n; i++)
        {
            // Check if the process is ready to execute
            if (p[i].at <= time && p[i].rt > 0)
            {
                found = true;

                // Execute the process for the time quantum or until completion
                if (p[i].rt > timeq)
                {
                    printf("| P%d ", p[i].name);
                    time += timeq;
                    p[i].rt -= timeq;
                }
                else
                {
                    printf("| P%d ", p[i].name);
                    time += p[i].rt;
                    p[i].rt = 0;
                    p[i].tat = time - p[i].at; // Calculate turnaround time
                    p[i].wt = p[i].tat - p[i].bt; // Calculate waiting time
                    completed++;
                }
            }
            // If no process is ready, simulate I/O wait
            else if (p[i].at > time)
            {
                printf("-");
                time += io_wait;
            }
        }

        // If no process is ready, increment time
        if (!found)
            time++;
    }

    // Output process metrics
    printf("\n Process\tAT\tBT\tTAT\tWT\n");
    printf("\n----------------------------------------\n");
    float avgtat = 0, avgwt = 0;
    for (i = 0; i < n; i++)
    {
        printf(" P%d    |\t%4d  |\t%4d  |\t%4d  |\t%4d |\n", p[i].name, p[i].at, p[i].bt, p[i].tat, p[i].wt);
        avgwt = avgwt + p[i].wt;
        avgtat = avgtat + p[i].tat;
    }

    // Output average turnaround time and average waiting time
    printf("\n\n Average Turn Around Time : %f", avgtat / n);
    printf("\n Average Waiting Time : %f\n", avgwt / n);
}



